<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gaoxuefeng&#39;s Blog</title>
  
  
  <link href="https://gaoxuefeng.com/atom.xml" rel="self"/>
  
  <link href="https://gaoxuefeng.com/"/>
  <updated>2026-02-22T15:25:05.223Z</updated>
  <id>https://gaoxuefeng.com/</id>
  
  <author>
    <name>gaoxuefeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AutoSnippet-将代码库中的模式提取为知识库</title>
    <link href="https://gaoxuefeng.com/posts/c6f37db"/>
    <id>https://gaoxuefeng.com/posts/c6f37db</id>
    <published>2026-02-08T17:42:37.000Z</published>
    <updated>2026-02-22T15:25:05.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我写了一个工具，让-AI-写代码终于像「我们团队的人」写的了"><a href="#我写了一个工具，让-AI-写代码终于像「我们团队的人」写的了" class="headerlink" title="我写了一个工具，让 AI 写代码终于像「我们团队的人」写的了"></a>我写了一个工具，让 AI 写代码终于像「我们团队的人」写的了</h1><blockquote><p>这篇文章介绍我开发的开源项目 <a href="https://github.com/GxFn/AutoSnippet">AutoSnippet</a>——一个代码模式知识库，让 Cursor、Copilot 等 AI 助手按你团队的规范生成代码。</p></blockquote><span id="more"></span><hr><h2 id="问题：AI-写的代码「能跑」但「不对味」"><a href="#问题：AI-写的代码「能跑」但「不对味」" class="headerlink" title="问题：AI 写的代码「能跑」但「不对味」"></a>问题：AI 写的代码「能跑」但「不对味」</h2><p>用 Cursor 或 Copilot 写了大半年代码，我发现一个越来越严重的问题——<strong>AI 生成的代码永远不像我们团队写的</strong>。</p><p>命名风格不一样，错误处理的方式不一样，架构分层不一样，甚至 import 的顺序都不一样。它写出来的东西从技术上是对的，但放到代码库里一眼就能看出「这不是我们的人写的」。</p><p>结果就是两个选择：要么花时间重写 AI 的输出让它符合规范，要么在每次 Code Review 里反复解释同样的约定。时间长了，AI 带来的效率提升被改代码的成本吃掉了一大半。</p><p>我想解决这个问题。</p><h2 id="思路：把团队的「暗知识」变成-AI-能查的知识库"><a href="#思路：把团队的「暗知识」变成-AI-能查的知识库" class="headerlink" title="思路：把团队的「暗知识」变成 AI 能查的知识库"></a>思路：把团队的「暗知识」变成 AI 能查的知识库</h2><p>每个团队都有很多「心照不宣」的规范：</p><ul><li>网络请求统一用哪个封装？超时怎么设？</li><li>ViewModel 里状态管理用什么模式？</li><li>日志怎么打？错误怎么向上透传？</li><li>这个项目里 <code>Manager</code> 和 <code>Service</code> 的命名边界在哪？</li></ul><p>这些东西写在 Wiki 里没人看，写在 Code Review 评论里随着 PR 沉底，存在每个老员工的脑子里随时可能流失。</p><p><strong>AutoSnippet 做的事情就是：把这些知识从代码里提取出来，结构化存储，然后在 AI 写代码时自动喂给它。</strong></p><p>流程很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你的代码 → AI 提取模式 → 你审核 → 知识库</span><br><span class="line">                                      ↓</span><br><span class="line">                        Cursor / Copilot / VS Code / Xcode</span><br><span class="line">                                      ↓</span><br><span class="line">                              AI 按你的规范生成代码</span><br></pre></td></tr></table></figure><h2 id="三条命令跑起来"><a href="#三条命令跑起来" class="headerlink" title="三条命令跑起来"></a>三条命令跑起来</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install -g autosnippet</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> your-project</span><br><span class="line">asd setup        <span class="comment"># 初始化工作空间 + 数据库 + IDE 配置</span></span><br><span class="line">asd coldstart    <span class="comment"># AI 扫描代码库，提取模式候选</span></span><br><span class="line">asd ui           <span class="comment"># 打开 Dashboard 审核</span></span><br></pre></td></tr></table></figure><p><code>asd setup</code> 会自动检测你装了哪些 IDE（Cursor、VS Code、Trae、Qoder），配好 MCP 连接。<code>asd coldstart</code> 会从 14 个维度扫描你的代码——架构模式、命名风格、设计模式、最佳实践、事件流、错误处理……扫描完生成一堆 <strong>Candidate</strong>（候选），等你审核。</p><p>打开 Dashboard，看到候选列表。每一条都是 AI 从你代码里提取出来的模式，有代码示例、使用说明、适用场景。你觉得好的，点通过，它就变成一条 <strong>Recipe</strong>（知识条目）进入知识库。觉得不好的就拒绝。</p><p>从此以后，IDE 里的 AI 写代码之前会先查你的 Recipe。</p><h2 id="它不只是「提示词工程」"><a href="#它不只是「提示词工程」" class="headerlink" title="它不只是「提示词工程」"></a>它不只是「提示词工程」</h2><p>我知道你在想什么——「这不就是把规范塞进 system prompt 吗」。不是的。</p><p>AutoSnippet 做的事情比往 prompt 里塞文本复杂得多：</p><h3 id="1-真正理解代码结构"><a href="#1-真正理解代码结构" class="headerlink" title="1. 真正理解代码结构"></a>1. 真正理解代码结构</h3><p>底层用 <strong>Tree-sitter</strong>（WASM 版本，不需要编译 C++）做 AST 解析，支持 9 种语言：JavaScript、TypeScript、Python、Swift、Objective-C、Java、Kotlin、Go、Ruby。不是正则匹配，是真的在解析语法树。</p><p>项目里有 11 个 Discoverer 自动识别项目类型（Node 项目、Flutter 项目、Spring 项目、Rust 项目……），还有 17 个 Enhancement Pack 针对具体框架（React、Vue、Next.js、Django、FastAPI、Spring、Android、Go gRPC、LangChain……）加上额外的分析逻辑。</p><h3 id="2-四层检索，不是全塞进去"><a href="#2-四层检索，不是全塞进去" class="headerlink" title="2. 四层检索，不是全塞进去"></a>2. 四层检索，不是全塞进去</h3><p>AI 问「网络请求怎么写」的时候，不是把整个知识库塞给它。搜索引擎有四层漏斗：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键词匹配 → BM25 评分 → 语义向量重排 → 多信号融合排序</span><br></pre></td></tr></table></figure><p>先精确匹配，再语义理解，最后综合质量评分、使用频率、新鲜度等多个信号排出最相关的几条。支持中英文。</p><h3 id="3-有-Token-预算控制"><a href="#3-有-Token-预算控制" class="headerlink" title="3. 有 Token 预算控制"></a>3. 有 Token 预算控制</h3><p>AI 的上下文窗口是有限的。AutoSnippet 有一个 <code>KnowledgeCompressor</code>，会根据当前情况动态压缩知识内容，确保在 token 预算内塞进最有价值的信息，而不是简单地截断。</p><h3 id="4-Guard-——-规范不止要建议，还要检查"><a href="#4-Guard-——-规范不止要建议，还要检查" class="headerlink" title="4. Guard —— 规范不止要建议，还要检查"></a>4. Guard —— 规范不止要建议，还要检查</h3><p>提取出来的 Recipe 不仅用来「告诉 AI 怎么写」，还会衍生出 Guard 规则用来「检查代码有没有按规范写」。</p><p>Guard 引擎内置了 50+ 规则，涵盖：</p><ul><li><strong>正确性</strong>：ObjC <code>dispatch_sync(main queue)</code> 死锁、Swift <code>DispatchQueue.main.sync</code> 死锁</li><li><strong>安全性</strong>：<code>eval()</code>、SQL 注入、硬编码密钥</li><li><strong>性能</strong>：循环内的不必要分配、Dart 的 <code>setState</code> 调用</li><li><strong>风格</strong>：命名约定、代码组织方式</li></ul><p>可以接到 CI 流水线（<code>asd guard:ci</code>）和 git pre-commit hook（<code>asd guard:staged</code>），在代码合入前自动卡住不合规的。</p><h2 id="IDE-深度集成"><a href="#IDE-深度集成" class="headerlink" title="IDE 深度集成"></a>IDE 深度集成</h2><p>AutoSnippet 通过 <a href="https://modelcontextprotocol.io/">MCP（Model Context Protocol）</a> 和 IDE 通信。MCP 是 Anthropic 推出的开放协议，让 AI 模型能够访问外部工具和数据。</p><p>共 16 个 MCP 工具：搜索知识库、浏览知识、Guard 检查、项目结构探查、知识创建、候选管理……IDE 里的 AI 可以按需调用这些工具。</p><h3 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h3><p>效果最好的 IDE。除了 MCP，还支持：</p><ul><li><strong>Cursor Rules</strong>——把 Recipe 摘要写入 <code>.cursor/rules/</code>，AI 自动遵守</li><li><strong>Agent Skills</strong>——20 个 Skill 包，AI 不只查知识库，还能扫描代码、创建候选、执行 Guard 检查</li><li><strong>自然语言驱动</strong>——在 Cursor 里直接说「帮我提取一下 network 模块的规范」，AI 会自动调 MCP 完成</li></ul><h3 id="VS-Code-Copilot"><a href="#VS-Code-Copilot" class="headerlink" title="VS Code (Copilot)"></a>VS Code (Copilot)</h3><p>MCP Server + 自研 VS Code 扩展，支持：</p><ul><li><strong>CodeLens</strong>——在代码上方直接显示关联的 Recipe</li><li><strong>文件指令</strong>——在代码里写 <code>// as:s network timeout</code> 自动搜索并插入相关知识</li><li><strong>保存时检查</strong>——保存文件自动触发 Guard 审计</li></ul><h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><p>通过 <code>asd watch</code> 文件监听实现，支持文件指令检测、代码片段同步。</p><h2 id="Dashboard-——-不只是个列表页"><a href="#Dashboard-——-不只是个列表页" class="headerlink" title="Dashboard —— 不只是个列表页"></a>Dashboard —— 不只是个列表页</h2><p><code>asd ui</code> 启动的 Dashboard 是一个功能完整的 Web 管理界面（React + Vite + Tailwind），包含：</p><ul><li><strong>Recipe 浏览器</strong>——搜索、过滤、查看完整知识条目</li><li><strong>Candidate 审核台</strong>——审核 AI 扫描出来的候选，通过&#x2F;拒绝&#x2F;编辑</li><li><strong>AI Chat</strong>——内置的 AI 对话，背后是一个 ReAct 推理引擎 + DAG 任务管线，支持 54 个内置工具</li><li><strong>知识图谱</strong>——可视化展示知识之间的关联关系</li><li><strong>Guard 报告</strong>——合规检查的可视化结果</li><li><strong>模块探查器</strong>——浏览项目的模块结构和依赖关系</li><li><strong>Wiki 生成</strong>——一键从知识库生成项目 Wiki</li><li><strong>LLM 配置</strong>——在界面上切换 AI Provider，不用改 <code>.env</code></li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>我花了很多心思在架构上。采用分层领域驱动设计（Layered DDD）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IDE 接入层       Cursor · VS Code · Trae · Qoder · Xcode · Dashboard</span><br><span class="line">                                     │</span><br><span class="line">                             MCP Server + HTTP API</span><br><span class="line">                                     │</span><br><span class="line">服务层           Search · Knowledge · Guard · Chat · Bootstrap · Wiki</span><br><span class="line">                                     │</span><br><span class="line">核心层           AST (9 lang) · KnowledgeGraph · RetrievalFunnel · QualityScorer</span><br><span class="line">                                     │</span><br><span class="line">基础设施层       SQLite · VectorStore · EventBus · AuditLog · DI Container (40+)</span><br></pre></td></tr></table></figure><p>几个我比较满意的设计决策：</p><ul><li><strong>Markdown 是真相来源</strong>——Recipe 存为 Markdown 文件，SQLite 只是读缓存。数据库坏了 <code>asd sync</code> 重建，但 Markdown 文件能直接看、直接改、直接进 Git</li><li><strong>无编译步骤</strong>——纯 JavaScript（ESM），不用 TypeScript 编译（Dashboard 除外）。Node.js ≥ 20 直接跑</li><li><strong>WASM AST</strong>——<code>web-tree-sitter</code> 替代原生 <code>tree-sitter</code>，彻底摆脱 C++ 编译依赖，<code>npm install</code> 就能用</li><li><strong>自研 DI 容器</strong>——40+ 服务的懒加载单例注入，不依赖任何外部 DI 框架。支持 AI Provider 热重载</li><li><strong>宪法系统（RBAC）</strong>——三层权限架构：能力层（运行时探测）、角色层（IDE AI &#x2F; 内置 AI &#x2F; 开发者）、治理层（4 条硬规则）。确保 AI 不会在没有你确认的情况下删除数据或发布内容</li></ul><h2 id="AI-Provider-支持"><a href="#AI-Provider-支持" class="headerlink" title="AI Provider 支持"></a>AI Provider 支持</h2><p>不绑定任何一家。支持 Google Gemini、OpenAI、Claude、DeepSeek、Ollama（本地）。配多个 Key 会自动 fallback——Gemini 挂了切 OpenAI，OpenAI 挂了切 DeepSeek。</p><p>甚至不配 AI 也能用——知识库本身不依赖 AI。你手动写 Recipe Markdown 文件，<code>asd sync</code> 进库，搜索和 Guard 照样工作。AI 只是让「从代码里提取模式」这一步自动化了。</p><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>最初是 macOS Only（因为有 Xcode 功能），3.0.9 版本做了一次深度跨平台审计，修复了 7 处 macOS 专属依赖：</p><ul><li>剪贴板操作：macOS <code>pbcopy</code> &#x2F; Linux <code>wl-copy</code> + <code>xclip</code> &#x2F; Windows PowerShell</li><li>通知：macOS <code>osascript</code> &#x2F; Linux <code>notify-send</code> &#x2F; Windows UWP Toast</li><li>IDE 发现：三个平台各自的路径探测</li><li>路径解析：<code>readlink -f</code> → Node.js 原生 <code>fs.realpathSync()</code></li></ul><p>现在 macOS &#x2F; Linux &#x2F; Windows 都能用了（Xcode 功能除外）。</p><h2 id="和现有工具的区别"><a href="#和现有工具的区别" class="headerlink" title="和现有工具的区别"></a>和现有工具的区别</h2><table><thead><tr><th></th><th>AutoSnippet</th><th>ESLint &#x2F; Biome</th><th>.cursorrules 手写</th></tr></thead><tbody><tr><td>知识来源</td><td>AI 从代码提取 + 人工审核</td><td>手写规则</td><td>手写</td></tr><tr><td>覆盖范围</td><td>架构&#x2F;模式&#x2F;惯例&#x2F;最佳实践</td><td>语法&#x2F;格式</td><td>自由文本</td></tr><tr><td>维护方式</td><td>持续从代码演化</td><td>手动更新配置</td><td>手动更新文件</td></tr><tr><td>AI 交付</td><td>MCP 协议自动推送</td><td>不涉及 AI</td><td>仅限 Cursor</td></tr><tr><td>合规检查</td><td>Guard (正则 + AST)</td><td>有</td><td>无</td></tr><tr><td>多 IDE 支持</td><td>Cursor&#x2F;VS Code&#x2F;Trae&#x2F;Qoder&#x2F;Xcode</td><td>IDE 无关</td><td>仅 Cursor</td></tr></tbody></table><p><strong>AutoSnippet 不替代 ESLint</strong>，它们覆盖的层次不同。ESLint 管代码格式和语法规则，AutoSnippet 管「我们团队怎么写网络请求」「ViewModel 里状态怎么管」这种更高层的东西。</p><h2 id="真实使用场景"><a href="#真实使用场景" class="headerlink" title="真实使用场景"></a>真实使用场景</h2><p>我自己在几个项目上跑 AutoSnippet。举几个场景：</p><p><strong>场景一：新人入职</strong></p><p>新人 clone 代码后跑 <code>asd setup &amp;&amp; asd coldstart</code>，知识库自动建好了。在 Cursor 里写代码的时候，AI 直接按团队规范生成。以前新人需要一两周摸索的「团队暗知识」，现在第一天就能用上。</p><p><strong>场景二：大型重构</strong></p><p>重构前先 <code>asd guard:ci</code> 生成合规报告，看看哪些模块偏离了规范。重构过程中 Guard 实时检查，确保新代码符合模式。重构完再扫描一遍，把新模式沉淀进知识库。</p><p><strong>场景三：跨模块开发</strong></p><p>你要改一个不熟的模块。在 Cursor 里问「这个模块的错误处理规范是什么」，MCP 自动搜索知识库返回相关 Recipe，附带代码示例和使用指南。不用翻 Wiki，不用问人。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>AutoSnippet 解决的核心问题是：<strong>AI 编码助手缺乏团队上下文</strong>。</p><p>它不是另一个 prompt 模板工具，而是一个完整的知识管理基础设施——从提取、审核、存储、检索到交付的全链路。</p><p>项目开源（MIT），欢迎试用和反馈：</p><ul><li><strong>GitHub</strong>: <a href="https://github.com/GxFn/AutoSnippet">github.com&#x2F;GxFn&#x2F;AutoSnippet</a></li><li><strong>npm</strong>: <code>npm install -g autosnippet</code></li><li><strong>文档</strong>: 项目内 <code>docs/</code> 目录有完整的架构设计、CLI 参考、配置指南、IDE 集成说明</li></ul><p>如果你的团队也被 AI 生成代码「不合规范」困扰，试试看。三条命令就能跑起来。</p><hr><p><em>作者：gaoxuefeng</em><br><em>项目版本：v3.0.x</em><br><em>License: MIT</em></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;我写了一个工具，让-AI-写代码终于像「我们团队的人」写的了&quot;&gt;&lt;a href=&quot;#我写了一个工具，让-AI-写代码终于像「我们团队的人」写的了&quot; class=&quot;headerlink&quot; title=&quot;我写了一个工具，让 AI 写代码终于像「我们团队的人」写的了&quot;&gt;&lt;/a&gt;我写了一个工具，让 AI 写代码终于像「我们团队的人」写的了&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍我开发的开源项目 &lt;a href=&quot;https://github.com/GxFn/AutoSnippet&quot;&gt;AutoSnippet&lt;/a&gt;——一个代码模式知识库，让 Cursor、Copilot 等 AI 助手按你团队的规范生成代码。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>枪炮、病菌与钢铁:人类社会的命运</title>
    <link href="https://gaoxuefeng.com/posts/e3a4c4e5"/>
    <id>https://gaoxuefeng.com/posts/e3a4c4e5</id>
    <published>2021-04-12T08:56:04.000Z</published>
    <updated>2021-04-12T12:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是2019年看完的第一本书，这本书阐述了人类历史中导致如今各个民族发展进程不相同的几项必要因素。这本书并不能当做一本科普读物，因为很多和实际并不相符的地方，但剥离充分条件去谈必要条件的思考方式是可以学习的。</p><span id="more"></span><h3 id="卡哈马卡的冲突"><a href="#卡哈马卡的冲突" class="headerlink" title="卡哈马卡的冲突"></a>卡哈马卡的冲突</h3><p>公元1492年，哥伦布到达加勒比海诸岛。从此，先进的“旧大陆”与美洲“新大陆”开始发生碰撞。公元1532年11月16日，西班牙文盲冒险家和征服者，弗郎西斯科·皮萨罗，率领着他那由62名骑兵和106个步兵组成的疲惫不堪的弱小入侵部队，在印加帝国的卡哈马卡，会见了拥有六百万人口，当时带领八万名随从的印加帝国皇帝阿塔瓦尔帕。</p><p>皮萨罗率领着他那支小得可怜的部队，一举擒获了印加皇帝阿塔瓦尔帕，在天黑之前杀死了6000到7000名印第安人。其余7万多印第安人只是因为夜幕降临，西班牙人已经累得无力继续屠杀才告幸免。在随后的几年时间里，皮萨罗率领着他那支袖珍部队，最终灭亡了拥有600万人口的印加帝国，并在印加帝国的废墟上建立了西班牙人在南美洲的第一个大型殖民地秘鲁。</p><p>书里的内容比较多，这里内容取自百度百科。这此冲突的结果看起来匪夷所思，但这就是既定的事实，于是作者根据这个既定事实开始探讨必然条件。</p><p>关于这种思考方式有一个更易于理解的例子，『一个人他的每代子孙里至少有一个男性，连续1000代，概率大约是多少？』，这个概率可能会非常的小。但如果逆推的话，这个人一定存在，就是你的父亲的父亲的父亲乘以1000。对他而言现在既定的事实无论多荒谬都是必然。</p><h3 id="粮食生产是终极因素"><a href="#粮食生产是终极因素" class="headerlink" title="粮食生产是终极因素"></a>粮食生产是终极因素</h3><p>人类刚开始在各个大陆游历的时候是狩猎采集族群，狩猎采集族群的生活方式是『凶险、粗野、短命』。粮食生产让人类定居，定居导致了人口增长，推动了文字和国家的诞生。也正是因为粮食生产在各个大陆发展的程度不同，导致了各个区域之间出现了发展差距。</p><p>欧亚大陆有更容易驯养种植的蛋白质丰富的大麦小麦等多种植物，更容易种植方面作者介绍了自花传粉不容易导致突变等等，有更多可以驯化的大型动物来发展农业，而且欧亚大陆是横向延伸，同纬度传播有相似的气候优势。</p><p>与之对比的是美洲大陆自身缺少适合驯养种植的植物，而大型动物大量被灭绝，美洲大陆是纵向延伸，不同纬度气候差异非常大，不利于农作物传播。粮食生产这一终极因素，在最一开始就拉开了新旧大陆的发展差距。</p><p>对于美洲大陆缺少大型动物，书里面的解释是，人类起源于非洲大陆和欧亚大陆，在那里学习狩猎，当地的动物跟随人类一起进步，对人类的狩猎有抵抗能力。而狩猎族群跨越白令海峡迁移到美洲大陆后，当地的大型动物面对狩猎技能满点的人类，无可奈何的走向了灭绝。</p><p>书里还引述了托尔斯泰伟大的小说《安娜·卡列尼娜》著名的第一句话：“幸福的家庭都是幸福的；不幸的家庭各有各的不幸。”托尔斯泰这句话的意思是，为了得到幸福，婚姻必须在许多不同方面都是成功的：两性的吸引、对金钱的共识、对孩子的管教、宗教信仰、三亲六眷，以及其他重大问题。在所有这些基本方面只要有一个方面出了问题，就可使婚姻毁掉，即使这婚姻所有其他必要的幸福因素一样不少。用来讲述动物驯化成功需要避免哪些问题。</p><h3 id="病毒、文字、技术和国家"><a href="#病毒、文字、技术和国家" class="headerlink" title="病毒、文字、技术和国家"></a>病毒、文字、技术和国家</h3><p>又是很多很有意思的观点了。</p><p>欧洲人在美洲杀掉的人远不及欧洲人带来的病毒杀掉的人多，而欧洲人之所有有那么多病毒，是因为人数众多的定居环境和动物的驯养。人类的大部分流行病都是源自动物。</p><p>文字的诞生是非常困难的，全世界的文字只是几种文字的借用，传播过程主要有两种，一种是知道文字的发明过程，照个这个过程根据自己民族的发音派生一个新的文字，另一种是思想的传播，知道文字的思想，自己开发一种。</p><p>很多发明创造其实并不是因为需求而来的，发明常常是需求之母。很多发明之所以变得有价值，是发明家坚持不懈的缝缝补补，让这个发明变得有用了，可能已经不是发明时的需求了。</p><p>狩猎采集族群都是家族为单位的小群体，小群体之间可能因为一点摩擦导致流血事件，就会导致一连串的仇杀，而且两个群体之间通常没有中间人拉架，流血慢慢升级。因为定居导致了人口增长，一旦人数大于一百多人，每个人能认识的有血缘关系的最大人数也就一百人，也会导致同样的问题，陌生人之间产生流血事件，没人拉架，这就孕育了酋长制的诞生，有一个核心人物保证大家不会互相残杀。随着人口的增长，国家的各种机制就建立起来了。现在的国家就是在陌生人之间残杀的时候，有人管理，来减少流血事件。</p><h3 id="中国的统一和欧洲的分裂"><a href="#中国的统一和欧洲的分裂" class="headerlink" title="中国的统一和欧洲的分裂"></a>中国的统一和欧洲的分裂</h3><p>中国在很早的时候就实现了一统，很大的弊端是一个声音就可以决定一件事，开辟新大陆时期中国的航海探险事业就是在一个声音下被毁灭的。而欧洲到现在都是分裂成多个国家，彼此之间存在竞争关系，一个国家接受了一个先进技术，如果其它国家不去学习就会被超越。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这本书一共四个部分，我按照四部分介绍了我觉得有意思的观点。关于这本书，我是在看晓说的时候看到的，高晓松有一次讲三体，说大刘是对人类社会历史有非常深刻了解的，三体里面的故事都能在人类社会历史里面找到对应，提到黑暗森林法则，一个文明灭绝另一个文明太正常不过了，提到了印加帝国被西班牙入侵到毁灭的事，也就是这本书第一部分第三章讲的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是2019年看完的第一本书，这本书阐述了人类历史中导致如今各个民族发展进程不相同的几项必要因素。这本书并不能当做一本科普读物，因为很多和实际并不相符的地方，但剥离充分条件去谈必要条件的思考方式是可以学习的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="book" scheme="https://gaoxuefeng.com/tags/book/"/>
    
  </entry>
  
</feed>
